#!/usr/bin/env bats   -*- bats -*-
#
# Regression test for flushing stale conntrack udp entries https://github.com/containers/netavark/issues/1045
#

load helpers

function start_sticky_udp_spammer() {
    local target_ip=$1
    local target_port=$2
    local message=$3

    cat << EOF > "$NETAVARK_TMPDIR/spammer.sh"
#!/bin/bash
# Open UDP connection to target on FD 3.
# Keeps Source Port constant.
exec 3<>/dev/udp/$target_ip/$target_port
while true; do
    echo "$message" >&3
    sleep 0.1
done
EOF
    chmod +x "$NETAVARK_TMPDIR/spammer.sh"
    run_in_host_netns "$NETAVARK_TMPDIR/spammer.sh" &
    SPAMMER_PID=$!
}

function run_ct_udp_flush_test() {
    local config_file=$1
    local target_ip=$2
    local target_port=$3
    local container_port=$4

    local msg="payload_$$"

    start_sticky_udp_spammer "$target_ip" "$target_port" "$msg"

    # avoid race condition and allow conntrack entry creation
    sleep 1

    run_in_host_netns conntrack -L
    assert "$output" =~ "dst=${target_ip}.*dport=${target_port}" "Conntrack flow matches target IP and Port"

    run_netavark --file "$config_file" setup $(get_container_netns_path)

    run_in_host_netns conntrack -L
    assert "$output" !~ "dst=${target_ip}.*dport=${target_port}" "Conntrack entry should NOT exist"

    run_in_container_netns timeout 1 sh -c "socat -u UDP4-LISTEN:$container_port STDOUT | head -n 1"

    local container_output="$output"

    kill $SPAMMER_PID
    wait $SPAMMER_PID || true
    run_netavark --file "$config_file" teardown $(get_container_netns_path)

    assert "$container_output" =~ "$msg" "received proper payload"
}

@test "nftables: receive udp traffic with pre-existing stale conntrack entry" {
    export NETAVARK_FW="nftables"
    # Explicitly add a rule to trigger connection tracking.
    # This ensures the traffic generated by the spammer creates a conntrack entry that
    # Netavark must flush. Without this, the kernel might not track the flow, preventing
    # the reproduction of the stale entry issue (causing a false positive test pass).
    run_in_host_netns nft -f - << EOF
add table inet bats {
    chain output {
        type filter hook output priority 0; policy accept;
        udp dport 10080 ct state new
    }
}
EOF
    run_ct_udp_flush_test "${TESTSDIR}/testfiles/bridge-udp-stale-conntrack.json" "127.0.0.1" "10080" "8080"
}

@test "nftables: receive udp traffic with pre-existing stale conntrack entry (range)" {
    export NETAVARK_FW="nftables"
    # Explicitly add a rule to trigger connection tracking for the range 10080-10081
    run_in_host_netns nft -f - << EOF
add table inet bats {
    chain output {
        type filter hook output priority 0; policy accept;
        udp dport 10080-10081 ct state new
    }
}
EOF
    run_ct_udp_flush_test "${TESTSDIR}/testfiles/bridge-udp-stale-conntrack-range.json" "127.0.0.1" "10081" "8081"
}

@test "firewalld: receive udp traffic with pre-existing stale conntrack entry" {
    setup_firewalld
    export NETAVARK_FW="firewalld"
    # Explicitly add a rule to trigger connection tracking.
    run_in_host_netns firewall-cmd --direct --add-rule ipv4 filter OUTPUT 0 -p udp -m state --state NEW -j ACCEPT
    run_ct_udp_flush_test "${TESTSDIR}/testfiles/bridge-udp-stale-conntrack.json" "127.0.0.1" "10080" "8080"
}

@test "firewalld: receive udp traffic with pre-existing stale conntrack entry (range)" {
    skip "port forwarding range seems to be broken with firewalld. All the traffic gets redirected to the first container port no matter which host range port you pick"

    setup_firewalld
    export NETAVARK_FW="firewalld"
    # Explicitly add a rule to trigger connection tracking.
    run_in_host_netns firewall-cmd --direct --add-rule ipv4 filter OUTPUT 0 -p udp -m state --state NEW -j ACCEPT
    run_ct_udp_flush_test "${TESTSDIR}/testfiles/bridge-udp-stale-conntrack-range.json" "127.0.0.1" "10081" "8081"
}
